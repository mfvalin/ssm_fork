#! /usr/bin/env python
# -*- coding: utf-8 -*-
#
# ssm/domain.py

# GPL--start
# This file is part of ssm (Simple Software Manager)
# Copyright (C) 2005-2012 Environment/Environnement Canada
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2
# of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
# GPL--end

"""Provides the Domain class.

The domain central to all that SSM does and its structure is
described below.

<domain_home>/
  etc/
    ssm.d/
      installed/
      login
      platforms/
      profile
      published/
      sources.list
      subdomains
      version
  lib/
    ssm.d/
      ssm_env_config.sh
      ssm_generateenvconfig.sh
      ssm_lib.sh
      ssm_platforms.sh
      ssm_subdomains.sh
  <platform_name>/
    bin/
    etc/
      ssm.d
    lib/
    share/
    sbin/
  ...
  <package_name>/
    ...
    
The contents under etc/ssm.d/:
1) maintain the state of the domain
2) provide the basic login and profile scripts used for shell
configuration.

The contents under lib/ssm.d/ are helpers for setting up the shell
environment for a whole domain (and subdomains) or a single package
within a domain.

Every package "lives" in its own directory under a domain and is
associated (by directory name) with a platform. The file and/or
directory members of a package are optional. Certain members are,
however, publishable (see PUBLISHABLE_NAMES below).

Packages "living" in a domain must have been properly installed and
and said to be "installed". Some packages may also be published,
which is simply having its PUBLISHABLE_NAMES symlinked to a
platform directory of a domain. All packages published to such a
directory share it; namespace collisions are not handled by SSM.

A domain supports an ordered list of platforms (determined by the
ssm_platforms.sh helper). Shell environment configuration is done
for each of the supported platforms so that the "best" match
platform is accessible before the next "best" match platform, etc.

A domain is simply a specially structure directory with the above
members and configuration.

Notes:
* ssm_generateenvconfig.sh is temporary and for backward compatibility
with <v9 ssmuse
"""

# system imports
import fnmatch
import os
import os.path
import pwd
import traceback

#
from ssm.constants import *
from ssm import globls
from ssm import utils
from ssm.package import Package

PUBLISHABLE_NAMES = [
    "bin",
    "etc/profile.d",    # special
    "include",
    "lib",
    "sbin",
    "share",
]

SSM_LOGIN_TEMPLATE = """
# login
#
# This script generated by 'ssm created' or 'ssm updated'. It is
# pointed by symlinks created by 'ssm subscribe' and sourced to set
# up the shell environment

setenv SSM_DOMAIN_HOME "%s"
eval `"${SSM_DOMAIN_HOME}/lib/ssm.d/ssm_env_config.sh" csh`
"""
#eval "`\\"${SSM_DOMAIN_HOME}/lib/ssm.d/ssm_env_config.sh\\" csh \\"${SSM_DOMAIN_HOME}\\"`"

SSM_PROFILE_TEMPLATE = """
# profile
#
# This script generated by 'ssm created' or 'ssm updated'. It is
# pointed by symlinks created by 'ssm subscribe' and sourced to set
# up the shell environment

export SSM_DOMAIN_HOME="%s"
eval "`\\"${SSM_DOMAIN_HOME}/lib/ssm.d/ssm_env_config.sh\\" sh`"
"""
#eval "`\\"${SSM_DOMAIN_HOME}/lib/ssm.d/ssm_env_config.sh\\" sh \\"${SSM_DOMAIN_HOME}\\"`"

class Domain:
    """Manager for a domain (existent or not).
    """

    def __init__(self, path=None):
        if path == None:
            path = os.environ.get("SSM_DOMAIN_HOME") \
                or os.environ.get("SSM_SYSTEM_DOMAIN_HOME") \
                or os.environ.get("SSM_USER_DOMAIN_HOME")
        self.path = os.path.realpath(path)

        #self.broken_path = "%s/etc/ssm.d/broken" % self.path
        self.frozen_path = "%s/etc/ssm.d/frozen" % self.path
        self.installed_path = "%s/etc/ssm.d/installed" % self.path
        self.label_path = "%s/etc/ssm.d/label" % self.path
        self.login_path = "%s/etc/ssm.d/login" % self.path
        self.platforms_path = "%s/etc/ssm.d/platforms" % self.path
        self.profile_path = "%s/etc/ssm.d/profile" % self.path
        self.published_path = "%s/etc/ssm.d/published" % self.path
        self.sources_path = "%s/etc/ssm.d/sources.list" % self.path
        self.subdomains_path = "%s/etc/ssm.d/subdomains" % self.path
        self.version_path = "%s/etc/ssm.d/version" % self.path

    # state
    def _get_state_link_dir(self, state_path, platform=None):
        if platform == None or self.get_version() < (10, 0):
            return state_path
        else:
            return "%s/%s" % (state_path, platform)

    def _add_state(self, state_path, pkg_path, platform=None):
        path = os.path.realpath(pkg_path)
        link_dir = self._get_state_link_dir(state_path, platform)
        link_name = "%s/%s" % (link_dir, os.path.basename(path))
        if os.path.lexists(link_name):
            utils.remove(link_name)
        if not os.path.isdir(link_dir):
            os.makedirs(link_dir)
        utils.symlink(path, link_name)

    def _find_package(self, package_name):
        try:
            if self.is_installed(package_name):
                package = Package(self, package_name)
            else:
                _, _, platform = package_name.split("_", 2)
                link_dir = self._get_state_link_dir(self.published_path, platform)
                link_path = os.path.join(link_dir, package_name)
                domain_home = os.path.dirname(os.path.realpath(link_path))
                domain = Domain(domain_home)
                package = Package(domain, package_name)
        except:
            package = None
        return package

    def _remove_state(self, state_path, pkg_path, platform=None):
        path = os.path.realpath(pkg_path)
        link_dir = self._get_state_link_dir(state_path, platform)
        link_name = "%s/%s" % (link_dir, os.path.basename(path))
        if os.path.lexists(link_name):
            utils.remove(link_name)

    def add_broken(self, path):
        return

        # disabled
        if os.path.isdir(self.broken_path):
            self._add_state(self.broken_path, path)

    def add_installed(self, path):
        self._add_state(self.installed_path, path)

    def add_published(self, path, platform=None):
        self._add_state(self.published_path, path, platform)

    def get_excluded_names(self):
        return []

    def get_broken(self):
        return []

        # disabled
        if os.path.isdir(self.broken_path):
            return utils.get_symlinks(self.broken_path)
        else:
            return []

    def get_installed(self):
        return utils.get_symlinks(self.installed_path)

    def get_label(self):
        return utils.loads(self.label_path)

    def get_owner(self):
        try:
            st = os.stat(self.path)
            s = pwd.getpwuid(st.st_uid).pw_name
        except:
            s = "***"
        return s

    def get_package_state(self, package_name, publish_platform=None):
        """Return package state string.
        I - installed
        P - published in install domain
        p - published not in install domain
        ? - broken
        """
        state = ""
        if self.is_installed(package_name):
            state += "I"
            if self.is_published(package_name, publish_platform):
                state += "P"
        elif self.is_published(package_name, publish_platform):
            state += "p"
        if self.is_broken(package_name):
            state += "?"
        return state

    def get_package_names(self, pattern="*"):
        """Return a list of all package names (whatever state).
        """
        paths = self.get_broken()
        paths.extend(self.get_installed())
        for published_platform in self.get_published_platforms():
            paths.extend(self.get_published(published_platform))
        package_name_map = dict([(os.path.basename(path), None) for path in paths])
        package_names = sorted(package_name_map.keys())
        package_names = fnmatch.filter(package_names, pattern)
        return package_names

    def get_packages_with_state(self, state, platform=None):
        """Return map of packages in a particular state.
        """
        if state == "broken":
            paths = self.get_broken()
        elif state == "installed":
            paths = self.get_installed()
        elif state == "published":
            paths = self.get_published(platform)
        else:
            paths = []

        m = {}
        for path in paths:
            domain_home = os.path.normpath(os.path.dirname(path))
            package_name = os.path.basename(path)
            if domain_home == self.path:
                domain = self
            else:
                domain = Domain(domain_home)
            m[package_name] = Package(domain, package_name)
            if domain != self:
                del domain
        return m

    def get_published(self, platform=None):
        if self.get_version() >= (10, 0):
            platforms = platform and [platform] or self.get_published_platforms()
            paths = ["%s/%s" % (self.published_path, platform) for platform in platforms]
        else:
            paths = [self.published_path]
        pub_paths = []
        for path in paths:
            try:
                if platform and self.get_version() < (10, 0):
                    suff = "_%s" % (platform,)
                    for linkname in utils.get_symlinks(path):
                        if linkname.endswith(suff):
                            pub_paths.append(linkname)
                else:
                    pub_paths.extend(utils.get_symlinks(path))
            except:
                pass
        return pub_paths

    def get_published_platforms(self):
        try:
            _, dirnames, _ = os.walk(self.published_path).next()
        except:
            dirnames = []
        if self.get_version() < (10, 0):
            platforms = []
            for dirname in dirnames:
                t = dirname.split("_", 2)
                if len(t) == 3:
                    platforms.append(t[2])
            dirnames = list(set(platforms))
        return dirnames

    def get_sources(self):
        return utils.loads(self.sources_path)

    def get_subdomains(self):
        paths = []
        if os.path.exists(self.subdomains_path):
            paths = [path for path in utils.loads(self.subdomains_path).split("\n") if path.strip() != ""]
        else:
            # <v9.0 support (limited availability)
            domainHomesPath = os.path.join(self.path, "etc/ssm.d/domainHomes")
            if os.path.isdir(domainHomesPath):
                # ints only; starting from 0; ignore 0
                names = sorted([int(name) for name in os.listdir(domainHomesPath) if name.isdigit()])[1:]
                names = map(str, names)
                paths = [os.readlink(os.path.join(domainHomesPath, name)) for name in names]
        return paths

    def get_version(self):
        try:
            return tuple(map(int, utils.loads(self.version_path).strip().split(".")))
        except:
            # when new/non-existent
            return (0, 0)

    def is_broken(self, package_name):
        return False

        # disabled
        return os.path.islink(os.path.join(self.broken_path, package_name))

    def is_compatible(self):
        if os.path.exists(os.path.join(self.path, "etc/ssm.d/meta.json")):
            return False

        version = self.get_version()
        if version < (11,):
            return True
        return False

    def is_domain(self):
        return os.path.exists(self.version_path)

    def is_frozen(self):
        return os.path.exists(self.frozen_path)

    def is_installed(self, package_name):
        return os.path.islink(os.path.join(self.installed_path, package_name))

    def is_published(self, package_name, publish_platform=None):
        inst_package = self._find_package(package_name)
        if publish_platform == None:
            publish_platform = inst_package.platform
        publish_package_name = "%s_%s_%s" % (inst_package.short_name, inst_package.version, publish_platform)
        link_dir = self._get_state_link_dir(self.published_path, publish_platform)
        #link_path = os.path.join(link_dir, publish_package_name)
        link_path = os.path.join(link_dir, package_name)
        try:
            return os.path.samefile(link_path, inst_package.path)
        except:
            return False

    def remove_broken(self, path):
        return

        # disabled
        if os.path.isdir(self.broken_path):
            self._remove_state(self.broken_path, path)

    def remove_installed(self, path):
        self._remove_state(self.installed_path, path)

    def remove_published(self, path, platform=None):
        self._remove_state(self.published_path, path, platform)

    def set_label(self, s):
        utils.dumps(s, self.label_path)

    def set_sources(self, s):
        utils.dumps(s, self.sources_path)

    def set_subdomains(self, subdomains):
        utils.dumps("\n".join(subdomains), self.subdomains_path)

    def set_version(self, s):
        utils.dumps(s, self.version_path)

    # operations
    def create(self, label, repo_source):
        """Create domain home.
        """
        if self.is_frozen():
            raise utils.SSMExitException("error: domain is frozen")

        if os.path.isdir(self.path) and not globls.force:
            raise utils.SSMExitException("error: domain already exists")

        try:
            # create domain dir tree
            utils.makedirs(self.path)
            #utils.makedirs(self.broken_path)
            utils.makedirs(self.installed_path)
            utils.makedirs(self.platforms_path)
            utils.makedirs(self.published_path)
            utils.makedirs("%s/lib/ssm.d" % self.path)

            # install working files and dirs
            if label:
                self.set_label(label)
            if repo_source:
                self.set_sources(repo_source)
            utils.touch("%s/etc/ssm.d/subdomains" % self.path)
            
            self.update_support()
        except:
            if globls.debug:
                traceback.print_exc()
            raise utils.SSMExitException("error: could not create domain")

    def freeze(self):
        """Mark as frozen.
        """
        utils.touch(self.frozen_path)

    def publish_package(self, package, platform=None):
        """Publish package to domain.
        """
        if self.is_frozen():
            raise utils.SSMExitException("error: domain is frozen")
        if package.domain.is_broken(package.name) and not globls.force:
            raise utils.SSMExitException("error: package is broken")

        try:
            if platform == None:
                platform = package.platform
            pkg_path_len = len(package.path)+1
            pub_dir = os.path.join(self.path, platform)
            if not os.path.exists(pub_dir):
                utils.makedirs(pub_dir)

            package.execute_script("pre-publish", self)

            for path in package.get_publishable_paths(PUBLISHABLE_NAMES):
                rel_path = path[pkg_path_len:]
                pub_path = os.path.join(pub_dir, rel_path)
                real_path = os.path.realpath(path)
                linkname = os.path.islink(path) and os.readlink(path)

                if rel_path in PUBLISHABLE_NAMES:
                    # enforce directory creation for publishable
                    # names even if the package uses a symlink
                    if not os.path.exists(pub_path):
                        utils.makedirs(pub_path)
                elif os.path.isdir(path) \
                    and (linkname == False or linkname[:2]+linkname[-2:] == ".//."):
                    if not os.path.exists(pub_path):
                        utils.makedirs(pub_path)
                elif os.path.isfile(path) or os.path.islink(path):
                    if globls.force:
                        utils.remove(pub_path)
                    utils.symlink(path, pub_path)

            package.execute_script("post-publish", self)
            
            self.add_published(package.path, platform)
            self.remove_broken(package.path)
        except:
            if globls.debug:
                traceback.print_exc()
            self.add_broken(package.path)
            raise utils.SSMExitException("error: could not publish")

    def unfreeze(self):
        """Remove "frozen" mark.
        """
        utils.remove(self.frozen_path)

    def unpublish_package(self, package, platform=None):
        """Unpublish package from domain.

        Match tail of published links against <package_name>/<tail> .

        Note: os.path.realpath(pub_path) resolves all symlinks, we
            want to resolve only the published one, therefore using
            os.readlink(pub_path).
        """
        if self.is_frozen():
            raise utils.SSMExitException("error: domain is frozen")

        try:
            inst_package = self._find_package(package.name)
            inst_package.execute_script("pre-unpublish", package.domain)

            if platform == None:
                package.platform
            pub_dir = os.path.join(self.path, platform)
            pub_dir_len = len(pub_dir)
            for root, dirnames, filenames in os.walk(pub_dir, topdown=False):
                for name in dirnames:
                    pub_path = os.path.join(root, name)
                    if os.path.islink(pub_path):
                        link_path = os.readlink(pub_path)
                        if not link_path.startswith("/"):
                            link_path = os.path.join(os.path.dirname(pub_path), link_path)
                        if os.path.islink(link_path):
                            # publish symlink to install symlink to a dir
                            filenames.append(name)
                    elif len(os.listdir(pub_path)) == 0:
                        utils.rmdir(pub_path)
                for name in filenames:
                    pub_path = os.path.join(root, name)
                    tail_pub_path = pub_path[pub_dir_len+1:]
                    match_path = os.path.join(package.name, tail_pub_path)
                    try:
                        real_pub_path = os.readlink(pub_path)
                    except:
                        utils.print_warning("warning: skipping unexpected non-symlink file (%s)" % pub_path)
                        continue

                    if real_pub_path.endswith(match_path):
                        utils.remove(pub_path)
            
            inst_package.execute_script("post-unpublish", package.domain)
            self.remove_published(package.path, platform)
            self.remove_broken(package.path)
        except:
            if globls.debug:
                traceback.print_exc()
            self.add_broken(package.path)
            raise utils.SSMExitException("error: could not unpublish")

    def update_support(self):
        """Update domain with new items.
        """
        if self.is_frozen():
            raise utils.SSMExitException("error: domain is frozen")

        utils.dumps(SSM_LOGIN_TEMPLATE % self.path, self.login_path)
        utils.dumps(SSM_PROFILE_TEMPLATE % self.path, self.profile_path)
        utils.copy(os.path.join(SSM_PKG_DIR, "etc/ssm.d/version"), self.version_path)
        #utils.dumps(VERSION, self.version_path)
        
        utils.rmtree(os.path.join(self.path, "etc/ssm.d/platforms"))
        utils.copytree(os.path.join(SSM_PKG_DIR, "etc/ssm.d/support/platforms"), os.path.join(self.path, "etc/ssm.d/platforms"))
        
        utils.copy(os.path.join(SSM_PKG_DIR, "lib/ssm.d/support/ssm_env_config.sh"), os.path.join(self.path, "lib/ssm.d/ssm_env_config.sh"))
        utils.copy(os.path.join(SSM_PKG_DIR, "lib/ssm.d/support/ssm_lib.sh"), os.path.join(self.path, "lib/ssm.d/ssm_lib.sh"))
        utils.copy(os.path.join(SSM_PKG_DIR, "lib/ssm.d/support/ssm_platforms.sh"), os.path.join(self.path, "lib/ssm.d/ssm_platforms.sh"))
        utils.copy(os.path.join(SSM_PKG_DIR, "lib/ssm.d/support/ssm_subdomains.sh"), os.path.join(self.path, "lib/ssm.d/ssm_subdomains.sh"))

        # temporary for <v9 compatibility with ssmuse
        utils.copy(os.path.join(SSM_PKG_DIR, "lib/ssm.d/support/ssm_generateenvconfig.sh"), os.path.join(self.path, "lib/ssm.d/ssm_generateenvconfig.sh"))
